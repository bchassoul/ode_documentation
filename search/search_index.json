{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Numerical Methods for Solving ODEs This documentation provides an overview of numerical methods for solving ordinary differential equations (ODEs) using Python. The methods covered include the Euler method, the second-order Runge-Kutta method (RK2), and the fourth-order Runge-Kutta method (RK4). Euler Method The Euler method is a first-order numerical procedure for solving ODEs. It is the simplest Runge-Kutta method. The formula for the Euler method is: which is the same as: y_next = y_current + h * f(t_current, y_current) where: y_next is the approximated solution at the next point. y_current is the current value of the solution. h is the step size. f(t_current, y_current) is the derivative of y at t_current . Second-order Runge-Kutta Method (RK2) The second-order Runge-Kutta method provides better accuracy than the Euler method. The formula for RK2 is: which is the same as: k1 = h * f(t_current, y_current) k2 = h * f(t_current + h/2, y_current + k1/2) y_next = y_current + k2 where: k1 and k2 are intermediate increments. y_next is the approximated solution at the next point. Fourth-order Runge-Kutta Method (RK4) The fourth-order Runge-Kutta method is one of the most widely used methods due to its balance between simplicity and accuracy. The formula for RK4 is: which is the same as: k1 = h * f(t_current, y_current) k2 = h * f(t_current + h/2, y_current + k1/2) k3 = h * f(t_current + h/2, y_current + k2/2) k4 = h * f(t_current + h, y_current + k3) y_next = y_current + (k1 + 2*k2 + 2*k3 + k4) / 6 where: k1 , k2 , k3 , and k4 are intermediate increments. y_next is the approximated solution at the next point. Reference For detailed documentation of the functions, visit the Reference Page . These numerical methods are fundamental for solving ODEs and are widely used in various scientific and engineering applications.","title":"Home"},{"location":"#numerical-methods-for-solving-odes","text":"This documentation provides an overview of numerical methods for solving ordinary differential equations (ODEs) using Python. The methods covered include the Euler method, the second-order Runge-Kutta method (RK2), and the fourth-order Runge-Kutta method (RK4).","title":"Numerical Methods for Solving ODEs"},{"location":"#euler-method","text":"The Euler method is a first-order numerical procedure for solving ODEs. It is the simplest Runge-Kutta method. The formula for the Euler method is: which is the same as: y_next = y_current + h * f(t_current, y_current) where: y_next is the approximated solution at the next point. y_current is the current value of the solution. h is the step size. f(t_current, y_current) is the derivative of y at t_current .","title":"Euler Method"},{"location":"#second-order-runge-kutta-method-rk2","text":"The second-order Runge-Kutta method provides better accuracy than the Euler method. The formula for RK2 is: which is the same as: k1 = h * f(t_current, y_current) k2 = h * f(t_current + h/2, y_current + k1/2) y_next = y_current + k2 where: k1 and k2 are intermediate increments. y_next is the approximated solution at the next point.","title":"Second-order Runge-Kutta Method (RK2)"},{"location":"#fourth-order-runge-kutta-method-rk4","text":"The fourth-order Runge-Kutta method is one of the most widely used methods due to its balance between simplicity and accuracy. The formula for RK4 is: which is the same as: k1 = h * f(t_current, y_current) k2 = h * f(t_current + h/2, y_current + k1/2) k3 = h * f(t_current + h/2, y_current + k2/2) k4 = h * f(t_current + h, y_current + k3) y_next = y_current + (k1 + 2*k2 + 2*k3 + k4) / 6 where: k1 , k2 , k3 , and k4 are intermediate increments. y_next is the approximated solution at the next point.","title":"Fourth-order Runge-Kutta Method (RK4)"},{"location":"#reference","text":"For detailed documentation of the functions, visit the Reference Page . These numerical methods are fundamental for solving ODEs and are widely used in various scientific and engineering applications.","title":"Reference"},{"location":"reference/","text":"Reference This section contains the documentation for the functions in the ode module. def euler ( f , y0 , t ): \"\"\"Euler method for solving ODEs. Args: f (function): Function that returns the derivative of y at t. y0 (float): Initial value. t (list of floats): Time points. Returns: list of floats: Approximated solution at each time point. \"\"\" y = [ y0 ] for i in range ( 1 , len ( t )): dt = t [ i ] - t [ i - 1 ] y . append ( y [ i - 1 ] + dt * f ( y [ i - 1 ], t [ i - 1 ])) return y def rk2 ( f , y0 , t ): \"\"\"Second-order Runge-Kutta method for solving ODEs. Args: f (function): Function that returns the derivative of y at t. y0 (float): Initial value. t (list of floats): Time points. Returns: list of floats: Approximated solution at each time point. \"\"\" y = [ y0 ] for i in range ( 1 , len ( t )): dt = t [ i ] - t [ i - 1 ] k1 = f ( y [ i - 1 ], t [ i - 1 ]) k2 = f ( y [ i - 1 ] + dt * k1 , t [ i - 1 ] + dt ) y . append ( y [ i - 1 ] + dt * ( k1 + k2 ) / 2 ) return y def rk4 ( f , y0 , t ): \"\"\"Fourth-order Runge-Kutta method for solving ODEs. Args: f (function): Function that returns the derivative of y at t. y0 (float): Initial value. t (list of floats): Time points. Returns: list of floats: Approximated solution at each time point. \"\"\" y = [ y0 ] for i in range ( 1 , len ( t )): dt = t [ i ] - t [ i - 1 ] k1 = f ( y [ i - 1 ], t [ i - 1 ]) k2 = f ( y [ i - 1 ] + dt * k1 / 2 , t [ i - 1 ] + dt / 2 ) k3 = f ( y [ i - 1 ] + dt * k2 / 2 , t [ i - 1 ] + dt / 2 ) k4 = f ( y [ i - 1 ] + dt * k3 , t [ i - 1 ] + dt ) y . append ( y [ i - 1 ] + dt * ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 ) return y","title":"Reference"},{"location":"reference/#reference","text":"This section contains the documentation for the functions in the ode module. def euler ( f , y0 , t ): \"\"\"Euler method for solving ODEs. Args: f (function): Function that returns the derivative of y at t. y0 (float): Initial value. t (list of floats): Time points. Returns: list of floats: Approximated solution at each time point. \"\"\" y = [ y0 ] for i in range ( 1 , len ( t )): dt = t [ i ] - t [ i - 1 ] y . append ( y [ i - 1 ] + dt * f ( y [ i - 1 ], t [ i - 1 ])) return y def rk2 ( f , y0 , t ): \"\"\"Second-order Runge-Kutta method for solving ODEs. Args: f (function): Function that returns the derivative of y at t. y0 (float): Initial value. t (list of floats): Time points. Returns: list of floats: Approximated solution at each time point. \"\"\" y = [ y0 ] for i in range ( 1 , len ( t )): dt = t [ i ] - t [ i - 1 ] k1 = f ( y [ i - 1 ], t [ i - 1 ]) k2 = f ( y [ i - 1 ] + dt * k1 , t [ i - 1 ] + dt ) y . append ( y [ i - 1 ] + dt * ( k1 + k2 ) / 2 ) return y def rk4 ( f , y0 , t ): \"\"\"Fourth-order Runge-Kutta method for solving ODEs. Args: f (function): Function that returns the derivative of y at t. y0 (float): Initial value. t (list of floats): Time points. Returns: list of floats: Approximated solution at each time point. \"\"\" y = [ y0 ] for i in range ( 1 , len ( t )): dt = t [ i ] - t [ i - 1 ] k1 = f ( y [ i - 1 ], t [ i - 1 ]) k2 = f ( y [ i - 1 ] + dt * k1 / 2 , t [ i - 1 ] + dt / 2 ) k3 = f ( y [ i - 1 ] + dt * k2 / 2 , t [ i - 1 ] + dt / 2 ) k4 = f ( y [ i - 1 ] + dt * k3 , t [ i - 1 ] + dt ) y . append ( y [ i - 1 ] + dt * ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 ) return y","title":"Reference"}]}